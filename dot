#!/usr/bin/env bash

set -euo pipefail

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly RESET='\033[0m'
readonly BOLD='\033[1m'

# Script metadata
readonly SCRIPT_NAME="dot"
readonly VERSION="1.0.0"
DOTFILES_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"
readonly DOTFILES_DIR

# Configuration
readonly PACKAGES_DIR="${DOTFILES_DIR}/packages"
readonly HOME_DIR="${DOTFILES_DIR}/home"
readonly GITHUB_EMAIL="ryanmiville@gmail.com"
readonly GITHUB_KEY_PATH="${HOME}/.ssh/id_ed25519.pub"


# Progress indicators
CURRENT_STEP=0
TOTAL_STEPS=0

# Helper functions
print_header() {
    echo -e "\n${BOLD}${BLUE}==>${RESET} ${BOLD}$1${RESET}"
}

print_success() {
    echo -e "${GREEN}✓${RESET} $1"
}

print_error() {
    echo -e "${RED}✗${RESET} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}⚠${RESET} $1"
}

print_info() {
    echo -e "${CYAN}ℹ${RESET} $1"
}

print_step() {
    ((CURRENT_STEP++))
    echo -e "\n${BOLD}[${CURRENT_STEP}/${TOTAL_STEPS}]${RESET} $1"
}

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

confirm() {
    local prompt="${1:-Continue?}"
    local default="${2:-n}"
    
    if [[ "$default" == "y" ]]; then
        prompt="$prompt [Y/n]: "
    else
        prompt="$prompt [y/N]: "
    fi
    
    read -r -p "$prompt" response
    
    case "$response" in
        [yY][eE][sS]|[yY]) return 0 ;;
        [nN][oO]|[nN]) return 1 ;;
        "")
            if [[ "$default" == "y" ]]; then
                return 0
            else
                return 1
            fi
            ;;
        *) return 1 ;;
    esac
}

check_dependencies() {
    local deps=("$@")
    local missing=()
    
    for dep in "${deps[@]}"; do
        if ! command_exists "$dep"; then
            missing+=("$dep")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        print_error "Missing dependencies: ${missing[*]}"
        return 1
    fi
    
    return 0
}

# Installation functions
install_homebrew() {
    print_step "Installing Homebrew"
    
    if command_exists brew; then
        print_success "Homebrew is already installed"
        return 0
    fi
    
    print_info "Homebrew is not installed. Installing now..."
    
    # Create temporary log file for installation output
    local log_file
    log_file=$(mktemp)
    local exit_code=0
    
    print_info "Running Homebrew installer (non-interactive mode)..."
    
    # Run installer with non-interactive flag and capture output
    if NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" > "$log_file" 2>&1; then
        print_success "Homebrew installation successful"
        
        # Configure Homebrew environment for the current session
        print_info "Configuring Homebrew environment..."
        if [[ "$(uname -m)" == "arm64" ]]; then
            eval "$(/opt/homebrew/bin/brew shellenv)"
        else
            eval "$(/usr/local/bin/brew shellenv)"
        fi
        print_success "Homebrew environment configured"
    else
        exit_code=$?
        print_error "Homebrew installation failed (exit code: $exit_code)"
        
        # Surface errors from the log
        print_info "Installation output:"
        if [[ -s "$log_file" ]]; then
            # Show last 20 lines of output for context
            tail -20 "$log_file" | while IFS= read -r line; do
                echo "  $line"
            done
        else
            print_warning "No installation output captured"
        fi
        
        # Common troubleshooting hints
        print_info "Troubleshooting:"
        print_info "  - Check if you have sufficient disk space"
        print_info "  - Ensure you have admin privileges"
        print_info "  - Check network connectivity"
        print_info "  - Try running manually: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
        
        rm "$log_file"
        return 1
    fi
    
    # Cleanup log file
    rm "$log_file"
}

install_packages() {
    print_step "Installing packages from Brewfile"
    
    if [[ ! -f "${PACKAGES_DIR}/bundle" ]]; then
        print_error "Base Brewfile not found at ${PACKAGES_DIR}/bundle"
        return 1
    fi
    
    print_info "Installing base packages..."
    
    # Try to install all packages at once first
    if brew bundle --file="${PACKAGES_DIR}/bundle"; then
        print_success "All base packages installed successfully"
    else
        print_warning "Some packages failed to install, trying individually..."
        
        # Parse Brewfile and try to install packages one by one
        local failed_packages=()
        local installed_count=0
        
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            # Extract package type and name
            if [[ "$line" =~ ^brew[[:space:]]+\"([^\"]+)\" ]]; then
                local package="${BASH_REMATCH[1]}"
                print_info "Installing brew package: $package"
                if brew install "$package" 2>/dev/null; then
                    ((++installed_count))
                else
                    print_warning "Failed to install: $package"
                    failed_packages+=("brew:$package")
                fi
            elif [[ "$line" =~ ^cask[[:space:]]+\"([^\"]+)\" ]]; then
                local package="${BASH_REMATCH[1]}"
                print_info "Installing cask: $package"
                if brew install --cask "$package" 2>/dev/null; then
                    ((++installed_count))
                else
                    print_warning "Failed to install: $package"
                    failed_packages+=("cask:$package")
                fi
            fi
        done < "${PACKAGES_DIR}/bundle"
        
        if [[ ${#failed_packages[@]} -gt 0 ]]; then
            print_warning "Failed to install ${#failed_packages[@]} packages:"
            printf "  - %s\n" "${failed_packages[@]}"
            
            # Save failed packages to a file for reference
            local failed_file
            failed_file="${PACKAGES_DIR}/failed_packages_$(date +%Y%m%d_%H%M%S).txt"
            printf "%s\n" "${failed_packages[@]}" > "$failed_file"
            print_info "Failed packages saved to: $failed_file"
        fi
        
        print_success "Successfully installed $installed_count packages"
    fi
    
    # Work packages
    if [[ -f "${PACKAGES_DIR}/bundle.work" ]] && confirm "Install work-specific packages?" "n"; then
        print_info "Installing work packages..."
        if brew bundle --file="${PACKAGES_DIR}/bundle.work" --no-lock; then
            print_success "Work packages installed successfully"
        else
            print_warning "Some work packages failed to install"
            
            # Try individual installation for work packages too
            local work_failed=()
            while IFS= read -r line; do
                [[ "$line" =~ ^[[:space:]]*# ]] && continue
                [[ -z "${line// }" ]] && continue
                
                if [[ "$line" =~ ^brew[[:space:]]+\"([^\"]+)\" ]]; then
                    local package="${BASH_REMATCH[1]}"
                    print_info "Installing work package: $package"
                    if ! brew install "$package" 2>/dev/null; then
                        work_failed+=("$package")
                    fi
                fi
            done < "${PACKAGES_DIR}/bundle.work"
            
            if [[ ${#work_failed[@]} -gt 0 ]]; then
                print_warning "Failed work packages: ${work_failed[*]}"
            fi
        fi
    fi
}

stow_dotfiles() {
    print_step "Stowing configuration files"
    
    if ! command_exists stow; then
        print_error "GNU Stow is not installed"
        print_info "Please install stow via Homebrew: brew install stow"
        return 1
    fi
    
    print_info "Stowing files from ${HOME_DIR} to ${HOME}..."
    
    # Create backup directory for existing configs
    local backup_dir
    backup_dir="${DOTFILES_DIR}/backups/$(date +%Y%m%d_%H%M%S)"
    local files_to_backup=()
    
    # Check for existing files that would be overwritten
    while IFS= read -r -d '' file; do
        local relative_path="${file#"${HOME_DIR}"/}"
        local target_path="${HOME}/${relative_path}"
        
        if [[ -e "$target_path" && ! -L "$target_path" ]]; then
            files_to_backup+=("$relative_path")
        fi
    done < <(find "${HOME_DIR}" -type f -print0)
    
    if [[ ${#files_to_backup[@]} -gt 0 ]]; then
        print_warning "The following files will be replaced:"
        printf "  %s\n" "${files_to_backup[@]}"
        
        if confirm "Create backups of existing files?" "y"; then
            mkdir -p "$backup_dir"
            for file in "${files_to_backup[@]}"; do
                local src="${HOME}/${file}"
                local dst="${backup_dir}/${file}"
                mkdir -p "$(dirname "$dst")"
                if ! cp -p "$src" "$dst"; then
                    print_error "Failed to backup: $src"
                    return 1
                fi
            done
            print_success "Backups created in ${backup_dir}"
        fi
    fi
    
    if stow -R -v -d "${DOTFILES_DIR}" -t "${HOME}" home; then
        print_success "Dotfiles stowed successfully"
    else
        print_error "Failed to stow dotfiles"
        return 1
    fi
}

install_bun() {
    print_step "Installing Bun"
    
    if command_exists bun; then
        print_success "Bun is already installed"
        return 0
    fi
    
    print_info "Installing Bun..."
    if curl -fsSL https://bun.sh/install | bash; then
        print_success "Bun installed successfully"
    else
        print_error "Failed to install Bun"
        return 1
    fi
}

# Helper to determine OpenCode installation method
get_opencode_install_method() {
    local opencode_path
    opencode_path=$(command -v opencode 2>/dev/null) || { echo "not_installed"; return; }
    
    case "$opencode_path" in
        "${HOME}/.opencode"*) echo "native" ;;
        "/opt/homebrew"*|"/usr/local/Cellar"*) echo "brew" ;;
        *".bun"*) echo "bun" ;;
        *"node_modules"*|*"/npm/"*) echo "npm" ;;
        *) echo "unknown" ;;
    esac
}

# Helper to check for multiple OpenCode installations
check_opencode_conflicts() {
    local found_paths=()
    
    # Check native installation
    if [[ -x "${HOME}/.opencode/bin/opencode" ]]; then
        found_paths+=("${HOME}/.opencode/bin/opencode (native)")
    fi
    
    # Check homebrew installation
    if command -v brew >/dev/null 2>&1; then
        local brew_path
        brew_path=$(brew --prefix 2>/dev/null)/bin/opencode
        if [[ -x "$brew_path" ]]; then
            found_paths+=("$brew_path (brew)")
        fi
    fi
    
    # Check bun global installation
    local bun_path="${HOME}/.bun/bin/opencode"
    if [[ -x "$bun_path" ]]; then
        found_paths+=("$bun_path (bun)")
    fi
    
    # Check npm global installation (common locations)
    local npm_paths=(
        "/usr/local/bin/opencode"
        "${HOME}/.npm-global/bin/opencode"
        "${HOME}/.local/bin/opencode"
    )
    for npm_path in "${npm_paths[@]}"; do
        if [[ -x "$npm_path" && "$npm_path" != "${HOME}/.opencode"* ]]; then
            found_paths+=("$npm_path (npm)")
        fi
    done
    
    if [[ ${#found_paths[@]} -gt 1 ]]; then
        echo "${found_paths[*]}"
        return 0
    fi
    return 1
}

install_opencode() {
    print_step "Installing OpenCode CLI"
    
    # Save current shell options for restoration
    local _saved_opts="$-"
    
    # Check current installation status
    local install_method
    install_method=$(get_opencode_install_method)
    
    case "$install_method" in
        native)
            print_success "OpenCode is already installed via native installer (recommended)"
            return 0
            ;;
        brew|bun|npm)
            print_warning "OpenCode is installed via $install_method"
            print_info "Native installer is recommended for faster updates"
            
            if confirm "Migrate to native installer?" "y"; then
                print_info "Migrating OpenCode to native installer..."
                
                # Temporarily disable exit on error
                set +e
                
                # Remove old installation
                case "$install_method" in
                    brew)
                        print_info "Removing Homebrew installation..."
                        brew uninstall opencode 2>/dev/null
                        ;;
                    bun)
                        print_info "Removing bun installation..."
                        bun remove -g opencode-ai 2>/dev/null
                        ;;
                    npm)
                        print_info "Removing npm installation..."
                        npm uninstall -g opencode-ai 2>/dev/null
                        ;;
                esac
                
                # Install via native installer
                print_info "Installing via native installer..."
                if curl -fsSL https://opencode.ai/install | bash; then
                    print_success "OpenCode migrated to native installer successfully"
                    print_info "You may need to restart your shell"
                    set -"$_saved_opts" 2>/dev/null || true
                    return 0
                else
                    print_error "Installation failed, reinstalling via $install_method..."
                    # Reinstall via original method
                    case "$install_method" in
                        brew) brew install opencode ;;
                        bun) bun install -g opencode-ai ;;
                        npm) npm install -g opencode-ai ;;
                    esac
                    set -"$_saved_opts" 2>/dev/null || true
                    return 1
                fi
            else
                print_info "Keeping existing $install_method installation"
                return 0
            fi
            ;;
        unknown)
            print_success "OpenCode is already installed"
            return 0
            ;;
    esac
    
    # Fresh installation - use native installer (fastest updates)
    print_info "Installing OpenCode CLI..."
    
    # Temporarily disable exit on error for installation attempts
    set +e
    
    # Try native installer first (recommended - gets updates faster than brew)
    print_info "Running native installer..."
    if curl -fsSL https://opencode.ai/install | bash; then
        print_success "OpenCode installed successfully via native installer"
        print_info "You may need to restart your shell or add ~/.opencode/bin to your PATH"
        set -"$_saved_opts" 2>/dev/null || true
        return 0
    else
        print_warning "Native installer failed, trying Homebrew..."
    fi
    
    # Fallback to Homebrew
    if command_exists brew; then
        print_info "Installing via Homebrew..."
        if brew install opencode; then
            print_success "OpenCode installed successfully via Homebrew"
            set -"$_saved_opts" 2>/dev/null || true
            return 0
        else
            print_warning "Homebrew installation failed, trying bun..."
        fi
    fi
    
    # Fallback to bun (faster than npm)
    if command_exists bun; then
        print_info "Installing via Bun..."
        if bun install -g opencode-ai; then
            print_success "OpenCode installed successfully via Bun"
            set -"$_saved_opts" 2>/dev/null || true
            return 0
        else
            print_warning "Bun installation failed, trying npm..."
        fi
    fi
    
    # Fallback to npm
    if command_exists npm; then
        print_info "Installing via npm..."
        if npm install -g opencode-ai; then
            print_success "OpenCode installed successfully via npm"
            set -"$_saved_opts" 2>/dev/null || true
            return 0
        else
            print_error "Failed to install OpenCode via npm"
            set -"$_saved_opts" 2>/dev/null || true
            return 1
        fi
    else
        print_error "All installation methods failed"
        print_info "Try manually: curl -fsSL https://opencode.ai/install | bash"
        set -"$_saved_opts" 2>/dev/null || true
        return 1
    fi
}

generate_ssh_key() {
    print_step "Generating SSH key for GitHub"
    
    if [[ -f "$GITHUB_KEY_PATH" ]]; then
        print_success "SSH key already exists at $GITHUB_KEY_PATH"
        return 0
    fi
    
    print_info "Generating new SSH key..."
    mkdir -p "${HOME}/.ssh"
    chmod 700 "${HOME}/.ssh"
    
    if ssh-keygen -t ed25519 -C "$GITHUB_EMAIL" -f "$GITHUB_KEY_PATH"; then
        print_success "SSH key generated successfully"
        print_info "Add the public key to GitHub:"
        echo "  pbcopy < ${GITHUB_KEY_PATH}.pub"
        echo "  Then go to: GitHub > Settings > SSH and GPG keys > New SSH key"
    else
        print_error "Failed to generate SSH key"
        return 1
    fi
}



cmd_gen_ssh_key() {
    print_header "Generating SSH key for GitHub"

    # Parse options
    local email=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat << EOF
${BOLD}USAGE:${RESET}
    ${SCRIPT_NAME} gen-ssh-key [EMAIL]

${BOLD}DESCRIPTION:${RESET}
    Generate a new SSH key for GitHub, GitLab, or other Git services.
    The key will be automatically added to ssh-agent and the public key
    will be copied to your clipboard for easy pasting.

${BOLD}ARGUMENTS:${RESET}
    EMAIL               Email address to associate with the SSH key (optional)
                        If not provided, you will be prompted for it

${BOLD}EXAMPLES:${RESET}
    ${SCRIPT_NAME} gen-ssh-key                          # Prompts for email
    ${SCRIPT_NAME} gen-ssh-key user@github.com          # Uses provided email
    ${SCRIPT_NAME} gen-ssh-key work@company.com         # Creates work key

${BOLD}NOTES:${RESET}
    - Key name is derived from email domain (e.g., user@github.com → id_ed25519_github)
    - Keys are stored in ~/.ssh/
    - Public key is automatically copied to clipboard
    - Key is automatically added to ssh-agent
    - If a key already exists, you will be prompted to overwrite

EOF
                return 0
                ;;
            *)
                email="$1"
                shift
                ;;
        esac
    done

    # Get email if not provided
    if [[ -z "$email" ]]; then
        read -r -p "Enter email address for SSH key: " email
        if [[ -z "$email" ]]; then
            print_error "Email is required"
            return 1
        fi
    fi

    # Validate email format (basic check)
    if [[ ! "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        print_error "Invalid email format: $email"
        return 1
    fi

    # Extract domain from email for key naming
    local domain
    domain=$(echo "$email" | sed 's/.*@//' | sed 's/\..*//')
    if [[ -z "$domain" ]]; then
        domain="key"
    fi

    # Sanitize domain name (remove special characters)
    domain=$(echo "$domain" | tr -cd '[:alnum:]_-' | tr '[:upper:]' '[:lower:]')

    # Set key path
    local key_name="id_ed25519_${domain}"
    local key_path="${HOME}/.ssh/${key_name}"

    print_info "Key will be created at: $key_path"

    # Check if key already exists
    if [[ -f "$key_path" ]]; then
        print_warning "SSH key already exists at $key_path"
        if ! confirm "Overwrite existing key?" "n"; then
            print_info "Key generation cancelled"
            return 0
        fi

        # Backup existing key
        local backup_path
        backup_path="${key_path}.backup.$(date +%Y%m%d_%H%M%S)"
        print_info "Backing up existing key to $(basename "$backup_path")"
        cp "$key_path" "$backup_path"
        cp "${key_path}.pub" "${backup_path}.pub" 2>/dev/null || true
    fi

    # Ensure .ssh directory exists with correct permissions
    mkdir -p "${HOME}/.ssh"
    chmod 700 "${HOME}/.ssh"

    # Generate SSH key
    print_info "Generating SSH key..."
    if ssh-keygen -t ed25519 -C "$email" -f "$key_path" -N ""; then
        print_success "SSH key generated successfully"
    else
        print_error "Failed to generate SSH key"
        return 1
    fi

    # Add key to ssh-agent
    print_info "Adding key to ssh-agent..."

    # Start ssh-agent if not running
    if ! pgrep -u "$USER" ssh-agent > /dev/null 2>&1; then
        print_info "Starting ssh-agent..."
        eval "$(ssh-agent -s)" > /dev/null
    fi

    if ssh-add "$key_path" 2>/dev/null; then
        print_success "Key added to ssh-agent"
    else
        print_warning "Failed to add key to ssh-agent (you may need to start ssh-agent)"
    fi

    # Copy public key to clipboard
    if command_exists pbcopy; then
        pbcopy < "${key_path}.pub"
        print_success "Public key copied to clipboard!"
    else
        print_warning "pbcopy not available, skipping clipboard copy"
    fi

    # Display instructions
    echo ""
    print_info "Next steps:"
    echo "  1. The public key has been copied to your clipboard"
    echo "  2. Go to your Git service (GitHub, GitLab, etc.):"
    echo "     - GitHub: Settings > SSH and GPG keys > New SSH key"
    echo "     - GitLab: Preferences > SSH Keys"
    echo "  3. Paste the key and save"
    echo ""
    print_info "Key details:"
    echo "  Private key: $key_path"
    echo "  Public key:  ${key_path}.pub"
    echo "  Email:       $email"
    echo ""

    # Show public key
    print_info "Public key contents:"
    cat "${key_path}.pub"
    echo ""

    print_success "SSH key generation complete!"
}



# Command functions
cmd_init() {
    print_header "Initializing dotfiles"
    
    TOTAL_STEPS=6
    CURRENT_STEP=0
    
    # Run all installation steps
    install_homebrew || return 1
    install_packages || return 1
    stow_dotfiles || return 1
    install_bun || return 1
    install_opencode || print_warning "OpenCode installation failed (continuing)"
    
    if [[ "${SKIP_SSH:-}" != "true" ]]; then
        generate_ssh_key || print_warning "SSH key generation failed (continuing)"
    fi
    
    print_header "Initialization complete!"
}

cmd_update() {
    print_header "Updating dotfiles"
    
    # Pull latest changes
    print_info "Pulling latest changes..."
    
    if git -C "$DOTFILES_DIR" pull; then
        print_success "Repository updated"
    else
        print_error "Failed to update repository"
        return 1
    fi
    
    # Update packages
    if confirm "Update Homebrew packages?" "y"; then
        print_info "Updating Homebrew..."
        brew update
        brew upgrade
        print_success "Packages updated"
    fi
    
    # Re-stow dotfiles
    if confirm "Re-stow dotfiles?" "y"; then
        stow_dotfiles
    fi
}

cmd_doctor() {
    print_header "Running diagnostics"
    
    local issues=0
    
    # Check Homebrew
    if command_exists brew; then
        print_success "Homebrew installed"
    else
        print_error "Homebrew not installed"
        ((++issues))
    fi
    
    # Check Stow
    if command_exists stow; then
        print_success "GNU Stow installed"
    else
        print_error "GNU Stow not installed"
        ((++issues))
    fi
    
    # Check OpenCode
    if command_exists opencode; then
        print_success "OpenCode installed"
        
        # Check installation method using helper function
        local install_method
        install_method=$(get_opencode_install_method)
        
        case "$install_method" in
            native)
                print_success "OpenCode installed via native installer (recommended)"
                ;;
            brew)
                print_warning "OpenCode installed via Homebrew"
                print_info "Native installer gets updates faster: curl -fsSL https://opencode.ai/install | bash"
                print_info "Or run 'dot init' to migrate automatically"
                ;;
            bun)
                print_warning "OpenCode installed via Bun"
                print_info "Native installer recommended: curl -fsSL https://opencode.ai/install | bash"
                print_info "Or run 'dot init' to migrate automatically"
                ;;
            npm)
                print_warning "OpenCode installed via npm"
                print_info "Native installer recommended: curl -fsSL https://opencode.ai/install | bash"
                print_info "Or run 'dot init' to migrate automatically"
                ;;
            *)
                print_warning "OpenCode installed via unknown method"
                print_info "Consider reinstalling via: curl -fsSL https://opencode.ai/install | bash"
                ;;
        esac
        
        # Check for multiple installations (potential conflicts)
        local conflicts
        if conflicts=$(check_opencode_conflicts); then
            print_warning "Multiple OpenCode installations detected:"
            for path in $conflicts; do
                print_info "  - $path"
            done
            print_info "This may cause version conflicts. Consider removing duplicate installations."
        fi
        
        # Check if we can get version (indicates it's working)
        if opencode --version >/dev/null 2>&1; then
            print_success "OpenCode is functional"
        else
            print_warning "OpenCode may need configuration"
            print_info "Run 'opencode' and use /connect to configure a provider"
        fi
    else
        print_warning "OpenCode not installed"
        print_info "Install with: curl -fsSL https://opencode.ai/install | bash"
        print_info "Or run 'dot init' to install automatically"
    fi
    
    # Check symlinks
    local broken_links=0
    while IFS= read -r -d '' link; do
        if [[ ! -e "$link" ]]; then
            ((++broken_links))
        fi
    done < <(find "${HOME}" -maxdepth 3 -type l -print0 2>/dev/null)
    
    if [[ $broken_links -eq 0 ]]; then
        print_success "No broken symlinks found"
    else
        print_warning "Found $broken_links broken symlinks"
    fi
    
    # Check SSH key
    if [[ -f "$GITHUB_KEY_PATH" ]]; then
        print_success "GitHub SSH key exists"
    else
        print_warning "GitHub SSH key not found"
    fi
    
    # Check key development tools
    local dev_tools=("git" "nvim" "node" "npm" "bun" "uv")
    local missing_tools=()
    
    for tool in "${dev_tools[@]}"; do
        if command_exists "$tool"; then
            print_success "$tool is available"
        else
            missing_tools+=("$tool")
        fi
    done
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        print_warning "Missing development tools: ${missing_tools[*]}"
    fi
    
    # Check if dotfiles directory is in PATH
    if echo "$PATH" | grep -q "$DOTFILES_DIR"; then
        print_success "Dotfiles directory is in PATH"
    else
        print_warning "Dotfiles directory not in PATH - 'dot' command may not work globally"
        print_info "Add 'export PATH=\"$DOTFILES_DIR:\$PATH\"' to your shell profile"
    fi
    
    if [[ $issues -eq 0 ]]; then
        print_header "All critical checks passed!"
        if [[ ${#missing_tools[@]} -gt 0 ]]; then
            print_info "Note: Some optional tools are missing but core functionality is intact"
        fi
    else
        print_header "Found $issues critical issues"
    fi
}

cmd_link() {
    print_header "Creating symlink for dot command"
    
    local target_dir="/usr/local/bin"
    local link_path="${target_dir}/dot"
    
    # Check if we can write to target directory
    if [[ ! -w "$target_dir" ]]; then
        print_info "Need sudo access to create symlink in ${target_dir}"
        target_dir="${HOME}/.local/bin"
        link_path="${target_dir}/dot"
        mkdir -p "$target_dir"
        print_info "Using ${target_dir} instead"
    fi
    
    # Remove existing link if present
    if [[ -L "$link_path" ]]; then
        rm "$link_path"
    fi
    
    # Create symlink
    if ln -s "${DOTFILES_DIR}/dot" "$link_path"; then
        print_success "Created symlink at ${link_path}"
        print_info "Make sure ${target_dir} is in your PATH"
    else
        print_error "Failed to create symlink"
        return 1
    fi
}

cmd_unlink() {
    print_header "Removing dot symlink"
    
    local paths=(
        "/usr/local/bin/dot"
        "${HOME}/.local/bin/dot"
        "/usr/local/bin/dotfiles"  # Legacy name
        "${HOME}/.local/bin/dotfiles"  # Legacy name
    )
    
    local found=false
    for link_path in "${paths[@]}"; do
        if [[ -L "$link_path" ]]; then
            if rm "$link_path"; then
                print_success "Removed symlink at ${link_path}"
                found=true
            else
                print_error "Failed to remove symlink at ${link_path}"
            fi
        fi
    done
    
    if [[ "$found" == false ]]; then
        print_warning "No dot symlink found"
    fi
}

cmd_stow() {
    print_header "Stowing dotfiles"

    if ! command_exists stow; then
        print_error "GNU Stow is not installed"
        print_info "Install it first: brew install stow"
        return 1
    fi

    local adopt=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --adopt) adopt=true; shift ;;
            *) print_error "Unknown option: $1"; return 1 ;;
        esac
    done

    local stow_args=(-R -v -d "${DOTFILES_DIR}" -t "${HOME}")
    [[ "$adopt" == true ]] && stow_args+=(--adopt)

    print_info "Creating symlinks for dotfiles..."

    if stow "${stow_args[@]}" home; then
        print_success "Dotfiles stowed successfully"
        print_info "Configuration files are now symlinked to your home directory"
    else
        print_error "Failed to stow dotfiles"
        print_info "Check for conflicting files in your home directory"
        return 1
    fi
}

cmd_edit() {
    print_header "Opening dotfiles in editor"
    
    local editor="${EDITOR:-nvim}"
    
    if command_exists "$editor"; then
        exec "$editor" "$DOTFILES_DIR" -c "cd $DOTFILES_DIR"
    else
        print_error "Editor '$editor' not found"
        print_info "Set EDITOR environment variable to specify your preferred editor"
        return 1
    fi
}

cmd_summary() {
    print_header "Summarizing recent changes"
    
    # Save current shell options for restoration
    local _saved_opts="$-"
    
    # Check if OpenCode is available
    if ! command_exists opencode; then
        print_error "OpenCode is not installed"
        print_info "Install it with: brew install opencode"
        print_info "Or run 'dot init' to install automatically"
        return 1
    fi
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        print_error "Not in a git repository"
        return 1
    fi
    
    # Parse options
    local num_commits=3
    local include_diff=false
    local verbose=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--number)
                num_commits="$2"
                shift 2
                ;;
            -d|--diff)
                include_diff=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -h|--help)
                cat << EOF
${BOLD}USAGE:${RESET}
    ${SCRIPT_NAME} summary [OPTIONS]

${BOLD}OPTIONS:${RESET}
    -n, --number NUM    Number of commits to summarize (default: 3)
    -d, --diff          Include diff in analysis for more detailed summary
    -v, --verbose       Show detailed commit info before summary
    -h, --help          Show this help

${BOLD}EXAMPLES:${RESET}
    ${SCRIPT_NAME} summary              # Summarize last 3 commits
    ${SCRIPT_NAME} summary -n 5         # Summarize last 5 commits  
    ${SCRIPT_NAME} summary -d           # Include diffs for detailed analysis
    ${SCRIPT_NAME} summary -v -n 2      # Verbose mode, 2 commits

EOF
                return 0
                ;;
            *)
                print_error "Unknown option: $1"
                print_info "Run '${SCRIPT_NAME} summary --help' for usage"
                return 1
                ;;
        esac
    done
    
    # Validate number of commits
    if ! [[ "$num_commits" =~ ^[0-9]+$ ]] || [[ "$num_commits" -lt 1 ]] || [[ "$num_commits" -gt 20 ]]; then
        print_error "Number of commits must be between 1 and 20"
        return 1
    fi
    
    print_info "Analyzing last $num_commits commit(s)..."
    
    # Get commit information
    local git_log_format="%H|%an|%ae|%ad|%s"
    local commits_info
    commits_info=$(git log --format="$git_log_format" --date=short -n "$num_commits")
    
    if [[ -z "$commits_info" ]]; then
        print_warning "No commits found"
        return 0
    fi
    
    # Show verbose info if requested
    if [[ "$verbose" == true ]]; then
        print_info "Recent commits:"
        echo "$commits_info" | while IFS='|' read -r hash author _ date subject; do
            local short_hash="${hash:0:8}"
            echo "  $short_hash - $subject ($author, $date)"
        done
        echo ""
    fi
    
    # Build prompt for OpenCode
    local ai_prompt="You are a technical writer. Provide ONLY a concise 2-3 paragraph summary of these Git commits. Do NOT ask questions or provide additional commentary. Focus on:
1. What changes were made (features, fixes, improvements)
2. Overall patterns or themes in the development
3. Any notable technical decisions or architectural changes

Here are the commits (most recent first):

"
    
    # Add commit details to prompt
    local commit_count=0
    local temp_commits_file
    temp_commits_file=$(mktemp -t DOT_commits_XXXXXX)
    echo "$commits_info" > "$temp_commits_file"
    
    # Process commits with better error handling
    set +e  # Temporarily disable exit on error for this section
    while IFS='|' read -r hash author _ date subject; do
        ((++commit_count))
        local short_hash="${hash:0:8}"
        ai_prompt+="Commit $commit_count ($short_hash, $date):
Subject: $subject
Author: $author
"
        
        # Add diff if requested
        if [[ "$include_diff" == true ]]; then
            local diff_output
            diff_output=$(git show --format="" --name-status "$hash" 2>/dev/null || true)
            if [[ -n "$diff_output" ]]; then
                ai_prompt+="Files changed:
$diff_output

"
            fi
        fi
        
        ai_prompt+="
"
    done < "$temp_commits_file"
    
    # Clean up temp file
    rm -f "$temp_commits_file"
    
    # Add instructions
    ai_prompt+="


INSTRUCTIONS: Respond with ONLY a concise 2-3 paragraph technical summary. Do not ask questions or provide additional commentary."
    
    # Create temporary file for the prompt
    local temp_file
    temp_file=$(mktemp -t DOT_prompt_XXXXXX)
    trap 'rm -f "$temp_file"' RETURN
    echo "$ai_prompt" > "$temp_file"

    print_info "Generating summary with OpenCode..."
    
    # Call OpenCode with explicit error handling
    local opencode_output=""
    local opencode_error=""
    local exit_code=0
    
    # Temporarily disable set -e to capture the exit code properly
    set +e
    opencode_output=$(opencode run < "$temp_file" 2>&1)
    exit_code=$?
    # Restore original shell options
    set -"$_saved_opts"
    
    if [[ $exit_code -eq 0 && -n "$opencode_output" ]]; then
        print_header "Summary of Recent Changes"
        echo ""
        echo "$opencode_output"
        echo ""
    else
        print_error "Failed to generate summary with OpenCode (exit code: $exit_code)"
        if [[ -n "$opencode_output" ]]; then
            opencode_error="$opencode_output"
        else
            opencode_error="No output received from OpenCode"
        fi
    fi
    
    # Handle errors if any occurred
    if [[ -n "${opencode_error:-}" ]]; then
        
        # Check if it's an authentication issue
        if echo "$opencode_output" | grep -q -i "auth\|login\|api\|connect"; then
            print_info "OpenCode needs configuration. Run: opencode and use /connect"
        elif echo "$opencode_output" | grep -q -i "network\|connection"; then
            print_info "Network connection issue. Check your internet connection"
        else
            print_info "OpenCode error: $opencode_output"
            print_info "Try running: opencode --version to verify installation"
        fi
        
        return 1
    fi

    # Show git log reference
    print_info "For detailed commit history, run: git log --oneline -n $num_commits"
}

cmd_retry_failed() {
    print_header "Retrying failed package installations"
    
    # Find the most recent failed packages file
    local failed_file
    failed_file=$(find "${PACKAGES_DIR}" -name "failed_packages_*.txt" -type f 2>/dev/null | sort -r | head -1)
    
    if [[ -z "$failed_file" || ! -f "$failed_file" ]]; then
        print_info "No failed packages file found"
        return 0
    fi
    
    print_info "Found failed packages file: $failed_file"
    print_info "Attempting to retry installation..."
    
    local retry_count=0
    local success_count=0
    
    while IFS= read -r package_info; do
        ((++retry_count))
        
        if [[ "$package_info" =~ ^brew:(.+)$ ]]; then
            local package="${BASH_REMATCH[1]}"
            print_info "Retrying brew package: $package"
            if brew install "$package" 2>/dev/null; then
                print_success "Successfully installed: $package"
                ((++success_count))
            else
                print_warning "Still failing: $package"
            fi
        elif [[ "$package_info" =~ ^cask:(.+)$ ]]; then
            local package="${BASH_REMATCH[1]}"
            print_info "Retrying cask: $package"
            if brew install --cask "$package" 2>/dev/null; then
                print_success "Successfully installed: $package"
                ((++success_count))
            else
                print_warning "Still failing: $package"
            fi
        fi
    done < "$failed_file"
    
    print_info "Retry complete: $success_count/$retry_count packages installed"
    
    if [[ $success_count -eq $retry_count ]]; then
        print_success "All failed packages now installed!"
        rm "$failed_file"
    fi
}

cmd_check_packages() {
    print_header "Checking installed packages"
    
    local missing_brew=()
    local missing_cask=()
    local installed_brew=()
    local installed_cask=()
    
    # Get lists of installed packages once to avoid repeated calls
    local installed_formulas
    local installed_casks
    installed_formulas=$(brew list --formula 2>/dev/null || true)
    installed_casks=$(brew list --cask 2>/dev/null || true)
    
    # Check base packages
    if [[ -f "${PACKAGES_DIR}/bundle" ]]; then
        print_info "Checking base packages..."
        
        while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            if [[ "$line" =~ ^brew[[:space:]] ]]; then
                local package
                package=$(echo "$line" | sed -n 's/^brew "\([^"]*\)".*/\1/p')
                if [[ -n "$package" ]]; then
                    # Extract formula name (last part after /) for tap packages
                    local formula_name="${package##*/}"
                    if echo "$installed_formulas" | grep -q "^${formula_name}$"; then
                        installed_brew+=("$package")
                    else
                        missing_brew+=("$package")
                    fi
                fi
            elif [[ "$line" =~ ^cask[[:space:]] ]]; then
                local package
                package=$(echo "$line" | sed -n 's/^cask "\([^"]*\)".*/\1/p')
                if [[ -n "$package" ]]; then
                    if echo "$installed_casks" | grep -q "^${package}$"; then
                        installed_cask+=("$package")
                    else
                        missing_cask+=("$package")
                    fi
                fi
            fi
        done < "${PACKAGES_DIR}/bundle"
    fi
    
    # Check work packages
    if [[ -f "${PACKAGES_DIR}/bundle.work" ]]; then
        print_info "Checking work packages..."
        
        while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            if [[ "$line" =~ ^brew[[:space:]] ]]; then
                local package
                package=$(echo "$line" | sed -n 's/^brew "\([^"]*\)".*/\1/p')
                if [[ -n "$package" ]]; then
                    # Extract formula name (last part after /) for tap packages
                    local formula_name="${package##*/}"
                    if echo "$installed_formulas" | grep -q "^${formula_name}$"; then
                        installed_brew+=("$package (work)")
                    else
                        missing_brew+=("$package (work)")
                    fi
                fi
            fi
        done < "${PACKAGES_DIR}/bundle.work"
    fi
    
    # Report results
    print_header "Package Status Report"
    
    echo -e "\n${BOLD}Installed Packages:${RESET}"
    print_success "Brew formulas: ${#installed_brew[@]}"
    print_success "Casks: ${#installed_cask[@]}"
    
    if [[ ${#missing_brew[@]} -gt 0 || ${#missing_cask[@]} -gt 0 ]]; then
        echo -e "\n${BOLD}Missing Packages:${RESET}"
        
        if [[ ${#missing_brew[@]} -gt 0 ]]; then
            print_warning "Missing brew formulas (${#missing_brew[@]}):"
            printf "  - %s\n" "${missing_brew[@]}"
        fi
        
        if [[ ${#missing_cask[@]} -gt 0 ]]; then
            print_warning "Missing casks (${#missing_cask[@]}):"
            printf "  - %s\n" "${missing_cask[@]}"
        fi
        
        echo ""
        print_info "Run '${SCRIPT_NAME} init' to install missing packages"
    else
        print_success "All packages are installed!"
    fi
}

cmd_package() {
    local subcommand="${1:-list}"
    shift || true
    
    case "$subcommand" in
        add)
            cmd_package_add "$@"
            ;;
        remove)
            cmd_package_remove "$@"
            ;;
        update)
            cmd_package_update "$@"
            ;;
        list)
            cmd_package_list "$@"
            ;;
        -h|--help|help)
            cmd_package_help
            ;;
        *)
            print_error "Unknown package subcommand: $subcommand"
            print_info "Run '${SCRIPT_NAME} package help' for usage"
            return 1
            ;;
    esac
}

cmd_package_add() {
    local package_name="$1"
    local package_type="${2:-auto}"
    local bundle_file="${3:-base}"
    
    if [[ -z "$package_name" ]]; then
        print_error "Package name required"
        print_info "Usage: ${SCRIPT_NAME} package add <package-name> [brew|cask] [base|work]"
        return 1
    fi
    
    # Determine bundle file
    local target_bundle
    if [[ "$bundle_file" == "work" ]]; then
        target_bundle="${PACKAGES_DIR}/bundle.work"
    else
        target_bundle="${PACKAGES_DIR}/bundle"
    fi
    
    # Auto-detect package type if not specified
    if [[ "$package_type" == "auto" ]]; then
        print_info "Detecting package type..."
        # Use brew info --json for more precise package detection
        if brew info --json=v2 --formula "$package_name" >/dev/null 2>&1; then
            package_type="brew"
        elif brew info --json=v2 --cask "$package_name" >/dev/null 2>&1; then
            package_type="cask"
        else
            print_warning "Package '$package_name' not found in either formulas or casks"
            print_info "Defaulting to brew formula. Use 'brew' or 'cask' to specify explicitly"
            package_type="brew"
        fi
    fi
    
    # Validate package type
    if [[ "$package_type" != "brew" && "$package_type" != "cask" ]]; then
        print_error "Package type must be 'brew' or 'cask'"
        return 1
    fi
    
    # Check if package already exists in bundle
    local package_line="${package_type} \"${package_name}\""
    if grep -q "^${package_line}$" "$target_bundle" 2>/dev/null; then
        print_warning "Package '$package_name' already exists in $(basename "$target_bundle")"
        return 0
    fi
    
    print_header "Adding $package_type package: $package_name"
    
    # Install the package first
    print_info "Installing package..."
    if [[ "$package_type" == "cask" ]]; then
        if brew install --cask "$package_name"; then
            print_success "Package installed successfully"
        else
            print_error "Failed to install package"
            return 1
        fi
    else
        if brew install "$package_name"; then
            print_success "Package installed successfully"
        else
            print_error "Failed to install package"
            return 1
        fi
    fi
    
    # Add to bundle file
    print_info "Adding to bundle file..."
    if [[ ! -f "$target_bundle" ]]; then
        print_warning "Bundle file doesn't exist, creating: $target_bundle"
        mkdir -p "$(dirname "$target_bundle")"
        touch "$target_bundle"
    fi
    
    # Find the right place to insert the package (keep them sorted)
    local temp_file
    temp_file=$(mktemp)
    local inserted=false
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # If this is a package line of the same type and comes after our package alphabetically
        if [[ "$line" =~ ^${package_type}[[:space:]]+\"([^\"]+)\" ]] && [[ "$inserted" == false ]]; then
            local existing_package="${BASH_REMATCH[1]}"
            if [[ "$package_name" < "$existing_package" ]]; then
                echo "$package_line" >> "$temp_file"
                inserted=true
            fi
        fi
        echo "$line" >> "$temp_file"
    done < "$target_bundle"
    
    # If we haven't inserted yet, add at the end
    if [[ "$inserted" == false ]]; then
        echo "$package_line" >> "$temp_file"
    fi
    
    # Replace the original file
    mv "$temp_file" "$target_bundle"
    
    print_success "Added '$package_name' to $(basename "$target_bundle")"
    print_info "Package will be included in future installations"
}

cmd_package_remove() {
    local package_name="$1"
    local bundle_file="${2:-auto}"
    # Escape regex metacharacters in package name
    local escaped_package
    # shellcheck disable=SC2016 # Single quotes intentional - \& is sed backreference
    escaped_package=$(printf '%s' "$package_name" | sed 's/[.[\*^$()+?{|\\]/\\&/g')

    if [[ -z "$package_name" ]]; then
        print_error "Package name required"
        print_info "Usage: ${SCRIPT_NAME} package remove <package-name> [base|work|auto]"
        return 1
    fi
    
    print_header "Removing package: $package_name"
    
    # Determine which bundle files to check
    local bundle_files=()
    if [[ "$bundle_file" == "work" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle.work")
    elif [[ "$bundle_file" == "base" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle")
    else
        # Auto mode - check both
        bundle_files=("${PACKAGES_DIR}/bundle" "${PACKAGES_DIR}/bundle.work")
    fi
    
    local found=false
    local package_type=""
    
    # Find and remove from bundle files
    for target_bundle in "${bundle_files[@]}"; do
        if [[ ! -f "$target_bundle" ]]; then
            continue
        fi
        
        # Check if package exists
        if grep -q "^\\(brew\\|cask\\)[[:space:]]*\"${escaped_package}\"" "$target_bundle"; then
            found=true

            # Determine package type
            if grep -q "^brew[[:space:]]*\"${escaped_package}\"" "$target_bundle"; then
                package_type="formula"
            else
                package_type="cask"
            fi

            # Remove from bundle file
            print_info "Removing from $(basename "$target_bundle")..."
            local temp_file
            temp_file=$(mktemp)
            grep -v "^\\(brew\\|cask\\)[[:space:]]*\"${escaped_package}\"" "$target_bundle" > "$temp_file"
            mv "$temp_file" "$target_bundle"
            
            print_success "Removed '$package_name' from $(basename "$target_bundle")"
        fi
    done
    
    if [[ "$found" == false ]]; then
        print_warning "Package '$package_name' not found in any bundle files"
        return 0
    fi
    
    # Ask if user wants to uninstall the actual package
    if confirm "Uninstall '$package_name' from system?" "n"; then
        print_info "Uninstalling package..."
        if [[ "$package_type" == "cask" ]]; then
            if brew uninstall --cask "$package_name"; then
                print_success "Package uninstalled successfully"
            else
                print_warning "Failed to uninstall package (it may have dependencies)"
            fi
        else
            if brew uninstall "$package_name"; then
                print_success "Package uninstalled successfully"
            else
                print_warning "Failed to uninstall package (it may have dependencies)"
            fi
        fi
    else
        print_info "Package removed from bundle but left installed on system"
    fi
}

cmd_package_update() {
    local package_name="${1:-all}"
    local bundle_file="${2:-all}"
    
    print_header "Updating packages"
    
    # If updating a specific package
    if [[ "$package_name" != "all" ]]; then
        print_info "Updating specific package: $package_name"
        
        # Check if package is installed
        local is_formula=false
        local is_cask=false
        
        if brew list --formula | grep -q "^${package_name}$"; then
            is_formula=true
        elif brew list --cask | grep -q "^${package_name}$"; then
            is_cask=true  # Used in conditional logic below
        else
            print_error "Package '$package_name' is not installed"
            return 1
        fi
        
        # Update the specific package
        if [[ "$is_formula" == true ]]; then
            print_info "Updating brew formula: $package_name"
            if brew upgrade "$package_name"; then
                print_success "Updated $package_name successfully"
            else
                print_warning "Failed to update $package_name (may already be latest version)"
            fi
        elif [[ "$is_cask" == true ]]; then
            print_info "Updating cask: $package_name"
            if brew upgrade --cask "$package_name"; then
                print_success "Updated $package_name successfully"
            else
                print_warning "Failed to update $package_name (may already be latest version or not upgradeable)"
            fi
        fi
        return 0
    fi
    
    # Update all packages (default behavior)
    print_info "Updating Homebrew and all packages..."
    
    # Update Homebrew first
    print_info "Updating Homebrew..."
    if brew update; then
        print_success "Homebrew updated successfully"
    else
        print_error "Failed to update Homebrew"
        return 1
    fi
    
    # Determine which packages to update based on bundle filter
    local bundle_files=()
    local bundle_names=()
    
    if [[ "$bundle_file" == "work" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle.work")
        bundle_names=("work")
    elif [[ "$bundle_file" == "base" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle")
        bundle_names=("base")
    else
        # All mode - update everything installed, not just bundle packages
        print_info "Upgrading all installed packages..."
        
        # Upgrade all formulas
        print_info "Upgrading brew formulas..."
        if brew upgrade; then
            print_success "Brew formulas updated"
        else
            print_warning "Some brew formulas failed to update"
        fi
        
        # Upgrade all casks
        print_info "Upgrading casks..."
        if brew upgrade --cask; then
            print_success "Casks updated"
        else
            print_warning "Some casks failed to update"
        fi
        
        # Cleanup
        if confirm "Clean up old versions?" "y"; then
            print_info "Cleaning up old package versions..."
            brew cleanup
            print_success "Cleanup completed"
        fi
        
        return 0
    fi
    
    # Update packages from specific bundle(s)
    local updated_packages=()
    local failed_packages=()
    
    for i in "${!bundle_files[@]}"; do
        local target_bundle="${bundle_files[$i]}"
        local bundle_name="${bundle_names[$i]}"
        
        if [[ ! -f "$target_bundle" ]]; then
            print_warning "Bundle file not found: $(basename "$target_bundle")"
            continue
        fi
        
        print_info "Updating packages from ${bundle_name} bundle..."
        
        while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            if [[ "$line" =~ ^brew[[:space:]]+\"([^\"]+)\" ]]; then
                local package="${BASH_REMATCH[1]}"
                # Extract formula name (last part after /) for tap packages
                local formula_name="${package##*/}"
                
                # Check if package is installed
                if brew list --formula | grep -q "^${formula_name}$"; then
                    print_info "Updating brew formula: $package"
                    if brew upgrade "$formula_name" 2>/dev/null; then
                        updated_packages+=("$package (formula)")
                    else
                        # Package might already be up to date
                        print_info "$package is already up to date"
                    fi
                else
                    print_warning "Package $package not installed, skipping"
                fi
                
            elif [[ "$line" =~ ^cask[[:space:]]+\"([^\"]+)\" ]]; then
                local package="${BASH_REMATCH[1]}"
                
                # Check if cask is installed
                if brew list --cask | grep -q "^${package}$"; then
                    print_info "Updating cask: $package"
                    if brew upgrade --cask "$package" 2>/dev/null; then
                        updated_packages+=("$package (cask)")
                    else
                        # Cask might already be up to date or not upgradeable
                        print_info "$package is already up to date or not upgradeable"
                    fi
                else
                    print_warning "Cask $package not installed, skipping"
                fi
            fi
        done < "$target_bundle"
    done
    
    # Report results
    if [[ ${#updated_packages[@]} -gt 0 ]]; then
        print_success "Updated ${#updated_packages[@]} packages:"
        printf "  - %s\n" "${updated_packages[@]}"
    else
        print_info "All packages are already up to date"
    fi
    
    if [[ ${#failed_packages[@]} -gt 0 ]]; then
        print_warning "Failed to update ${#failed_packages[@]} packages:"
        printf "  - %s\n" "${failed_packages[@]}"
    fi
    
    # Cleanup
    if confirm "Clean up old versions?" "y"; then
        print_info "Cleaning up old package versions..."
        brew cleanup
        print_success "Cleanup completed"
    fi
}

cmd_package_list() {
    local bundle_file="${1:-all}"

    print_header "Listing packages"

    # Cache brew list output once to avoid SIGPIPE issues with pipefail
    local installed_formulas
    local installed_casks
    installed_formulas=$(brew list --formula 2>/dev/null || true)
    installed_casks=$(brew list --cask 2>/dev/null || true)

    # Determine which bundle files to list
    local bundle_files=()
    local bundle_names=()

    if [[ "$bundle_file" == "work" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle.work")
        bundle_names=("work")
    elif [[ "$bundle_file" == "base" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle")
        bundle_names=("base")
    else
        # All mode
        bundle_files=("${PACKAGES_DIR}/bundle" "${PACKAGES_DIR}/bundle.work")
        bundle_names=("base" "work")
    fi

    for i in "${!bundle_files[@]}"; do
        local target_bundle="${bundle_files[$i]}"
        local bundle_name="${bundle_names[$i]}"

        if [[ ! -f "$target_bundle" ]]; then
            if [[ "$bundle_file" != "all" ]]; then
                print_warning "Bundle file not found: $(basename "$target_bundle")"
            fi
            continue
        fi

        local cap_name
        cap_name=$(echo "$bundle_name" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')
        echo -e "\n${BOLD}${cap_name} packages ($(basename "$target_bundle")):${RESET}"

        local brew_packages=()
        local cask_packages=()

        while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue

            if [[ "$line" =~ ^brew[[:space:]]+\"([^\"]+)\" ]]; then
                brew_packages+=("${BASH_REMATCH[1]}")
            elif [[ "$line" =~ ^cask[[:space:]]+\"([^\"]+)\" ]]; then
                cask_packages+=("${BASH_REMATCH[1]}")
            fi
        done < "$target_bundle"

        if [[ ${#brew_packages[@]} -gt 0 ]]; then
            echo -e "  ${BOLD}Brew formulas (${#brew_packages[@]}):${RESET}"
            for package in "${brew_packages[@]}"; do
                # Extract formula name (last part after /) for tap packages like hashicorp/tap/terraform
                local formula_name="${package##*/}"
                if echo "$installed_formulas" | grep -q "^${formula_name}$"; then
                    print_success "    $package"
                else
                    print_error "    $package (not installed)"
                fi
            done
        fi

        if [[ ${#cask_packages[@]} -gt 0 ]]; then
            echo -e "  ${BOLD}Casks (${#cask_packages[@]}):${RESET}"
            for package in "${cask_packages[@]}"; do
                if echo "$installed_casks" | grep -q "^${package}$"; then
                    print_success "    $package"
                else
                    print_error "    $package (not installed)"
                fi
            done
        fi

        if [[ ${#brew_packages[@]} -eq 0 && ${#cask_packages[@]} -eq 0 ]]; then
            print_info "  No packages found"
        fi
    done
}

cmd_package_help() {
    echo -e "${BOLD}${SCRIPT_NAME} package${RESET} - Package management commands"
    echo ""
    
    echo -e "${BOLD}USAGE:${RESET}"
    echo "    ${SCRIPT_NAME} package [SUBCOMMAND] [OPTIONS]"
    echo ""
    
    echo -e "${BOLD}SUBCOMMANDS:${RESET}"
    echo "    add NAME [TYPE] [BUNDLE]   Add package to bundle and install it"
    echo "    remove NAME [BUNDLE]       Remove package from bundle and optionally uninstall"
    echo "    update [NAME] [BUNDLE]     Update packages (all packages by default)"
    echo "    list [BUNDLE]              List packages in bundle files (default)"
    echo "    help                       Show this help message"
    echo ""
    
    echo -e "${BOLD}PARAMETERS:${RESET}"
    echo "    NAME                       Package name (required for add/remove, optional for update)"
    echo "    TYPE                       Package type: 'brew' or 'cask' (auto-detected if not specified)"
    echo "    BUNDLE                     Bundle file: 'base', 'work', or 'all' (default varies by command)"
    echo ""
    
    echo -e "${BOLD}EXAMPLES:${RESET}"
    echo "    ${SCRIPT_NAME} package list               # List all packages"
    echo "    ${SCRIPT_NAME} package list base          # List base packages only"
    echo "    ${SCRIPT_NAME} package list work          # List work packages only"
    echo "    ${SCRIPT_NAME} package add git            # Add git formula to base bundle"
    echo "    ${SCRIPT_NAME} package add docker cask    # Add docker cask to base bundle"
    echo "    ${SCRIPT_NAME} package add kubectl brew work  # Add kubectl to work bundle"
    echo "    ${SCRIPT_NAME} package remove git         # Remove git from any bundle"
    echo "    ${SCRIPT_NAME} package remove docker base # Remove docker from base bundle only"
    echo "    ${SCRIPT_NAME} package update             # Update all installed packages"
    echo "    ${SCRIPT_NAME} package update git         # Update specific package"
    echo "    ${SCRIPT_NAME} package update all base    # Update only base bundle packages"
    echo "    ${SCRIPT_NAME} package update all work    # Update only work bundle packages"
    echo ""
    
    echo -e "${BOLD}NOTES:${RESET}"
    echo "    - Package type is auto-detected if not specified"
    echo "    - Packages are kept sorted alphabetically within each type"
    echo "    - Adding a package installs it immediately and adds to bundle"
    echo "    - Removing a package removes from bundle and optionally uninstalls"
    echo "    - Updating without arguments updates all installed packages"
    echo "    - Update command includes Homebrew refresh and optional cleanup"
    echo "    - Work bundle (bundle.work) is for work-specific packages"
    echo "    - Base bundle (bundle) is for general-purpose packages"
    echo ""
}

cmd_adopt() {
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat << EOF
${BOLD}USAGE:${RESET}
    ${SCRIPT_NAME} adopt <path>

${BOLD}DESCRIPTION:${RESET}
    Move a file or directory that was accidentally created inside a stow-managed
    symlinked location into the actual dotfiles repo, then re-stow so the
    symlink is (re-)created in its place.

    Example: a file created at ~/.config/opencode/plugins that should live in
    dotfiles/home/.config/opencode/plugins.

${BOLD}ARGUMENTS:${RESET}
    path    Path to the file or directory to adopt (must be under \$HOME)

${BOLD}EXAMPLES:${RESET}
    ${SCRIPT_NAME} adopt ~/.config/opencode/plugins
    ${SCRIPT_NAME} adopt ~/.config/opencode/config.json

EOF
                return 0
                ;;
            -*)
                print_error "Unknown option: $1"
                print_info "Run '${SCRIPT_NAME} adopt --help' for usage"
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    local target_path="${1:-}"

    if [[ -z "$target_path" ]]; then
        print_error "Path required"
        print_info "Usage: ${SCRIPT_NAME} adopt <path>"
        print_info "Run '${SCRIPT_NAME} adopt --help' for usage"
        return 1
    fi

    # Resolve to absolute path (works on macOS without GNU coreutils)
    local abs_path
    if [[ -e "$target_path" ]]; then
        if [[ -d "$target_path" ]]; then
            abs_path="$(cd "$target_path" && pwd)"
        else
            abs_path="$(cd "$(dirname "$target_path")" && pwd)/$(basename "$target_path")"
        fi
    else
        print_error "Path does not exist: $target_path"
        return 1
    fi

    # Must be under $HOME
    if [[ "$abs_path" != "${HOME}/"* ]]; then
        print_error "Path must be under \$HOME: $abs_path"
        return 1
    fi

    # Must not already be a symlink into dotfiles
    if [[ -L "$abs_path" ]]; then
        local link_target
        link_target="$(readlink "$abs_path")"
        # Resolve relative symlinks to absolute
        if [[ "$link_target" != /* ]]; then
            link_target="$(cd "$(dirname "$abs_path")" && pwd)/${link_target}"
        fi
        # Normalize .. components by letting cd resolve the path
        local normalized
        if [[ -d "$link_target" ]]; then
            normalized="$(cd "$link_target" 2>/dev/null && pwd)" || normalized="$link_target"
        else
            normalized="$(cd "$(dirname "$link_target")" 2>/dev/null && pwd)/$(basename "$link_target")" || normalized="$link_target"
        fi
        link_target="$normalized"
        if [[ "$link_target" == "${HOME_DIR}/"* || "$link_target" == "${HOME_DIR}" ]]; then
            print_success "$abs_path is already managed by dotfiles (symlink to $link_target)"
            return 0
        fi
        print_error "$abs_path is a symlink to $link_target (not into dotfiles)"
        print_info "Remove the symlink manually if you want to adopt this path"
        return 1
    fi

    local relative_path="${abs_path#"${HOME}/"}"
    local dotfiles_path="${HOME_DIR}/${relative_path}"

    print_header "Adopting into dotfiles"
    print_info "Source:      $abs_path"
    print_info "Destination: $dotfiles_path"

    # Target must not already exist in dotfiles
    if [[ -e "$dotfiles_path" ]]; then
        print_error "Already exists in dotfiles: $dotfiles_path"
        print_info "Remove it from dotfiles first if you want to replace it"
        return 1
    fi

    if ! command_exists stow; then
        print_error "GNU Stow is not installed"
        print_info "Install it first: brew install stow"
        return 1
    fi

    # Create parent dirs in dotfiles if needed
    local parent_dir
    parent_dir="$(dirname "$dotfiles_path")"
    if [[ ! -d "$parent_dir" ]]; then
        print_info "Creating parent directory in dotfiles: $parent_dir"
        mkdir -p "$parent_dir"
    fi

    # Move into dotfiles
    if ! mv "$abs_path" "$dotfiles_path"; then
        print_error "Failed to move $abs_path -> $dotfiles_path"
        return 1
    fi
    print_success "Moved to dotfiles"

    # Re-stow (creates the symlink back at the original location)
    if stow -R -v -d "${DOTFILES_DIR}" -t "${HOME}" home 2>&1; then
        print_success "Stowed — symlink created at $abs_path"
    else
        print_error "Stow failed — reverting move"
        mv "$dotfiles_path" "$abs_path"
        return 1
    fi

    print_success "Done! $relative_path is now tracked in dotfiles."
}

cmd_help() {
    echo -e "${BOLD}${SCRIPT_NAME}${RESET} - Dotfiles management tool"
    echo "Version: ${VERSION}"
    echo ""
    
    echo -e "${BOLD}USAGE:${RESET}"
    echo "    ${SCRIPT_NAME} [OPTIONS] COMMAND [ARGS]"
    echo ""
    
    echo -e "${BOLD}COMMANDS:${RESET}"
    echo "    init                Initialize and install dotfiles"
    echo "    update              Update dotfiles and packages"
    echo "    doctor              Run diagnostics and check installation"
    echo "    package             Package management commands (add, remove, list)"
    echo "    check-packages      Check which packages are installed/missing"
    echo "    retry-failed        Retry failed package installations"
    echo "    summary             Summarize recent git commits using OpenCode"
    echo "    gen-ssh-key         Generate SSH key for GitHub/GitLab with email"
    echo "    adopt               Move a stray file/dir into dotfiles and re-stow"
    echo "    stow                Create symlinks for dotfiles using GNU Stow"
    echo "    link                Install dot command globally (create symlink in PATH)"
    echo "    unlink              Uninstall global dot command (remove symlink)"
    echo "    edit                Open dotfiles in editor"
    echo "    help                Show this help message (default)"
    echo ""
    
    echo -e "${BOLD}OPTIONS:${RESET}"
    echo "    --skip-ssh      Skip SSH key generation"
    echo "    --version       Show version information"
    echo "    -h, --help      Show this help message"
    echo ""
    
    echo -e "${BOLD}EXAMPLES:${RESET}"
    echo "    ${SCRIPT_NAME} init                      # Full initialization"
    echo "    ${SCRIPT_NAME} init --skip-ssh           # Initialize without SSH setup"
    echo "    ${SCRIPT_NAME} update                    # Update everything"
    echo "    ${SCRIPT_NAME} doctor                    # Check installation health"
    echo "    ${SCRIPT_NAME} package list              # List all packages"
    echo "    ${SCRIPT_NAME} package add git           # Add git package to base bundle"
    echo "    ${SCRIPT_NAME} package update            # Update all packages"
    echo "    ${SCRIPT_NAME} package remove docker     # Remove docker from bundles"
    echo "    ${SCRIPT_NAME} check-packages            # See package installation status"
    echo "    ${SCRIPT_NAME} retry-failed              # Retry any failed installations"
    echo "    ${SCRIPT_NAME} summary                   # Summarize last 3 commits with AI"
    echo "    ${SCRIPT_NAME} summary -n 5 -d           # Detailed summary of last 5 commits"
    echo "    ${SCRIPT_NAME} gen-ssh-key               # Generate SSH key (prompts for email)"
    echo "    ${SCRIPT_NAME} gen-ssh-key user@github.com  # Generate SSH key with email"
    echo "    ${SCRIPT_NAME} adopt ~/.config/opencode/plugins  # Adopt stray dir into dotfiles"
    echo "    ${SCRIPT_NAME} stow                      # Create symlinks for dotfiles"
    echo "    ${SCRIPT_NAME} link                      # Install dot command globally in PATH"
    echo ""
    
    echo -e "${BOLD}CONFIGURATION:${RESET}"
    echo "    Dotfiles directory: ${DOTFILES_DIR}"
    echo "    Packages directory: ${PACKAGES_DIR}"
    echo "    Home directory:     ${HOME_DIR}"
    echo ""
    
    echo -e "${BOLD}NOTES:${RESET}"
    echo "    - Package installation is resilient to failures"
    echo "    - Failed packages are logged and can be retried later"
    echo "    - OpenCode CLI installed via native installer (with brew/bun/npm fallback)"
    echo "    - Doctor command checks all critical development tools"
    echo "    - Summary command uses AI to analyze and summarize git commits"
    echo ""
}

# Main function
main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --skip-ssh)
                export SKIP_SSH=true
                shift
                ;;
            --version)
                echo "${SCRIPT_NAME} version ${VERSION}"
                exit 0
                ;;
            -h|--help)
                cmd_help
                exit 0
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Get command
    local cmd="${1:-help}"
    shift || true
    
    # Execute command
    case "$cmd" in
        init)
            cmd_init "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        package)
            cmd_package "$@"
            ;;
        check-packages)
            cmd_check_packages "$@"
            ;;
        retry-failed)
            cmd_retry_failed "$@"
            ;;
        summary)
            cmd_summary "$@"
            ;;
        gen-ssh-key)
            cmd_gen_ssh_key "$@"
            ;;
        adopt)
            cmd_adopt "$@"
            ;;
        stow)
            cmd_stow "$@"
            ;;
        link)
            cmd_link "$@"
            ;;
        unlink)
            cmd_unlink "$@"
            ;;
        edit)
            cmd_edit "$@"
            ;;
        help)
            cmd_help
            ;;
        *)
            print_error "Unknown command: $cmd"
            echo "Run '${SCRIPT_NAME} help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
